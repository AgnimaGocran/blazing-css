use std::{
	collections::BTreeMap,
	env,
	error::Error,
	fs,
	path::{Path, PathBuf},
};

use blazing_css_core::{
	canonical_css_block_from_stream, hash_css_block, is_array_value, parse_array_value, CssBlock,
};
pub use blazing_css_macro::css;
use itertools::Itertools;
use proc_macro2::{Delimiter, TokenStream, TokenTree};

const BZC_VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Debug, Clone)]
pub struct RenderOptions {
	pub emit_cargo_directives: bool,
	pub break_points: Option<Vec<u32>>,
}

impl Default for RenderOptions {
	fn default() -> Self {
		Self {
			emit_cargo_directives: true,
			break_points: Some(vec![640, 1024, 1440]),
		}
	}
}

pub fn render_css(file_name: &str) -> Result<(), Box<dyn Error>> {
	render_css_with_options(file_name, RenderOptions::default())
}

pub fn render_css_with_options(
	file_name: &str, options: RenderOptions,
) -> Result<(), Box<dyn Error>> {
	render_css_internal(file_name, options, None)
}

pub fn render_css_with_options_in(
	file_name: &str, manifest_dir: &Path, options: RenderOptions,
) -> Result<(), Box<dyn Error>> {
	render_css_internal(file_name, options, Some(manifest_dir))
}

fn render_css_internal(
	file_name: &str, options: RenderOptions, manifest_override: Option<&Path>,
) -> Result<(), Box<dyn Error>> {
	let manifest_dir = if let Some(path) = manifest_override {
		path.to_path_buf()
	} else {
		PathBuf::from(env::var("CARGO_MANIFEST_DIR")?)
	};
	if options.emit_cargo_directives {
		println!("cargo:rerun-if-changed=build.rs");
	}

	let src_dir = manifest_dir.join("src");
	let files = collect_rust_files(&src_dir)?;
	let mut gathered: BTreeMap<PathBuf, Vec<MacroEntry>> = BTreeMap::new();

	for file in files {
		if options.emit_cargo_directives {
			println!("cargo:rerun-if-changed={}", file.display());
		}
		let entries = process_file(&file)?;
		if !entries.is_empty() {
			gathered.insert(file, entries);
		}
	}

	let styles_path = manifest_dir.join(file_name);
	write_stylesheet(
		&styles_path,
		&manifest_dir,
		&gathered,
		options.break_points.as_ref(),
	)?;

	Ok(())
}

fn collect_rust_files(dir: &Path) -> Result<Vec<PathBuf>, Box<dyn Error>> {
	let mut files = Vec::new();
	if dir.is_dir() {
		for entry in fs::read_dir(dir)? {
			let entry = entry?;
			let path = entry.path();
			if path.is_dir() {
				files.extend(collect_rust_files(&path)?);
			} else if path.extension().is_some_and(|ext| ext == "rs") {
				files.push(path);
			}
		}
	}
	files.sort();
	Ok(files)
}

fn process_file(path: &Path) -> Result<Vec<MacroEntry>, Box<dyn Error>> {
	let source = fs::read_to_string(path)?;
	let tokens = source.parse::<TokenStream>()?;
	let mut entries = Vec::new();
	scan_stream(tokens, &mut entries);
	Ok(entries)
}

fn scan_stream(stream: TokenStream, entries: &mut Vec<MacroEntry>) {
	let mut iter = stream.into_iter().peekable();
	while let Some(token) = iter.next() {
		match token {
			TokenTree::Ident(ident) if ident == "css" => {
				if matches!(iter.peek(), Some(TokenTree::Punct(p)) if p.as_char() == '!') {
					iter.next();
					if let Some(TokenTree::Group(group)) = iter.next() {
						if group.delimiter() == Delimiter::Brace {
							let inner = group.stream();
							let block = canonical_css_block_from_stream(&inner);
							let hash = hash_css_block(&block);
							entries.push(MacroEntry { hash, block });
							scan_stream(inner, entries);
							continue;
						}
						scan_stream(group.stream(), entries);
						continue;
					}
				}
			}
			TokenTree::Group(group) => {
				scan_stream(group.stream(), entries);
			}
			_ => {}
		}
	}
}

fn write_stylesheet(
	output_path: &Path, manifest_dir: &Path, files: &BTreeMap<PathBuf, Vec<MacroEntry>>,
	break_points: Option<&Vec<u32>>,
) -> Result<(), Box<dyn Error>> {
	let css_vars = if let Some(bps) = break_points {
		format_breakpoint_css_vars(bps)
	} else {
		String::new()
	};

	let content = files
		.iter()
		.map(|(file, entries)| {
			format!(
				"/* {file} */\n{styles}",
				file = file
					.strip_prefix(manifest_dir)
					.unwrap_or(file)
					.display()
					.to_string(),
				styles = entries
					.iter()
					.map(|entry| format_css_block(&entry.hash, &entry.block, break_points))
					.collect::<Vec<_>>()
					.join("\n\n")
			)
		})
		.join("\n\n");

	let header = format!("/* This is autogenerated file by blazing-css {BZC_VERSION}, do not edit it! */\n\n");
	let body = if css_vars.is_empty() {
		format!("{header}{content}")
	} else {
		format!("{header}{css_vars}\n\n{content}")
	};

	fs::write(output_path, body)?;
	Ok(())
}

/// Formats CSS variables for breakpoints
fn format_breakpoint_css_vars(break_points: &[u32]) -> String {
	let mut vars = Vec::new();
	for (i, bp) in break_points.iter().enumerate() {
		let name = match i {
			0 => "--bp-sm",
			1 => "--bp-md",
			2 => "--bp-lg",
			3 => "--bp-xl",
			_ => &format!("--bp-{}", i),
		};
		vars.push(format!("\t{}: {}px;", name, bp));
	}

	format!(":root {{\n{}\n}}", vars.join("\n"))
}

fn format_css_block(hash: &str, block: &CssBlock, break_points: Option<&Vec<u32>>) -> String {
	let scoped_block = scope_keyframes_in_block(hash, block);
	let segments = &scoped_block.segments;

	// Check if any root segment has array values with multiple elements (media queries)
	let has_multi_value_array = segments.iter().any(|seg| {
		if let Some((_, value)) = seg.split_once(':') {
			let value_trimmed = value.trim();
			if is_array_value(value_trimmed) {
				if let Some(array_values) = parse_array_value(value_trimmed) {
					array_values.len() > 1
				} else {
					false
				}
			} else {
				false
			}
		} else {
			false
		}
	});

	let root_rules = if has_multi_value_array {
		if let Some(bps) = break_points {
			format_media_queries_block(hash, segments, bps)
		} else {
			format_media_queries_block(hash, segments, &[640, 1024, 1440])
		}
	} else {
		let processed_segments: Vec<String> = segments
			.iter()
			.map(|seg| {
				if let Some((property, value)) = seg.split_once(':') {
					let value_trimmed = value.trim();
					if is_array_value(value_trimmed) {
						if let Some(array_values) = parse_array_value(value_trimmed) {
							if let Some(first_value) = array_values.first() {
								format!("{}: {}", property.trim(), first_value)
							} else {
								seg.clone()
							}
						} else {
							seg.clone()
						}
					} else {
						seg.clone()
					}
				} else {
					seg.clone()
				}
			})
			.collect();

		if processed_segments.is_empty() && scoped_block.children.is_empty() {
			format!(".{hash} {{\n}}", hash = hash)
		} else {
			format!(
				".{hash} {{\n{body}\n}}",
				hash = hash,
				body = format_css_segments(&processed_segments, 1)
			)
		}
	};

	let mut result = root_rules;
	for child in &scoped_block.children {
		if !result.is_empty() {
			result.push_str("\n\n");
		}
		result.push_str(&format_css_tree(hash, child, "", false));
	}
	result
}

/// Recursively formats a block and its children into selector groups.
fn format_css_tree(hash: &str, block: &CssBlock, parent_suffix: &str, in_keyframes: bool) -> String {
	if is_at_rule_selector(&block.selector_suffix) {
		return format_at_rule(hash, block, parent_suffix);
	}

	if in_keyframes {
		let selector = block.selector_suffix.trim();
		let body = format_css_segments(&block.segments, 1);
		return if body.is_empty() && block.children.is_empty() {
			format!("{selector} {{\n}}")
		} else {
			format!("{selector} {{\n{body}\n}}")
		};
	}

	let selector = format!(".{hash}{parent_suffix}{suffix}", suffix = block.selector_suffix);
	let body = format_css_segments(&block.segments, 1);
	let mut out = if body.is_empty() && block.children.is_empty() {
		format!("{selector} {{\n}}")
	} else {
		format!("{selector} {{\n{body}\n}}")
	};
	let next_suffix = format!("{parent_suffix}{}", block.selector_suffix);
	for child in &block.children {
		out.push_str("\n\n");
		out.push_str(&format_css_tree(hash, child, &next_suffix, false));
	}
	out
}

fn format_at_rule(hash: &str, block: &CssBlock, parent_suffix: &str) -> String {
	let selector = normalize_at_rule_selector(&block.selector_suffix);
	let is_keyframes = is_keyframes_rule(&selector);
	let mut body_blocks: Vec<String> = Vec::new();

	if !block.segments.is_empty() && !is_keyframes {
		let scoped_selector = format!(".{hash}{parent_suffix}");
		let scoped_body = format_css_segments(&block.segments, 1);
		body_blocks.push(indent_css_block(
			&format!("{scoped_selector} {{\n{scoped_body}\n}}"),
			1,
		));
	}

	for child in &block.children {
		let child_css = if is_keyframes {
			format_css_tree(hash, child, "", true)
		} else {
			format_css_tree(hash, child, parent_suffix, false)
		};
		body_blocks.push(indent_css_block(&child_css, 1));
	}

	if body_blocks.is_empty() {
		format!("{selector} {{\n}}")
	} else {
		format!("{selector} {{\n{}\n}}", body_blocks.join("\n\n"))
	}
}

fn indent_css_block(content: &str, indent_level: usize) -> String {
	let indent = "\t".repeat(indent_level);
	content
		.lines()
		.map(|line| format!("{indent}{line}"))
		.collect::<Vec<_>>()
		.join("\n")
}

fn is_at_rule_selector(selector: &str) -> bool {
	let trimmed = selector.trim_start();
	trimmed.starts_with('@') || trimmed.starts_with("@ ")
}

fn normalize_at_rule_selector(selector: &str) -> String {
	let mut normalized = selector.trim().replace("@ ", "@").replace(" - ", "-");
	while normalized.contains("  ") {
		normalized = normalized.replace("  ", " ");
	}
	normalized
}

fn keyframes_name_from_selector(selector: &str) -> Option<String> {
	let normalized = normalize_at_rule_selector(selector);
	let trimmed = normalized.trim();
	let lowercase = trimmed.to_ascii_lowercase();
	if !lowercase.starts_with("@keyframes") {
		return None;
	}

	let name = trimmed["@keyframes".len()..].trim();
	if name.is_empty() {
		None
	} else {
		Some(name.to_string())
	}
}

fn is_keyframes_rule(selector: &str) -> bool {
	keyframes_name_from_selector(selector).is_some()
}

fn scope_keyframes_in_block(hash: &str, block: &CssBlock) -> CssBlock {
	let mut mapping = BTreeMap::new();
	collect_keyframe_names(block, hash, &mut mapping);
	rewrite_block_with_keyframes(block, &mapping)
}

fn collect_keyframe_names(block: &CssBlock, hash: &str, mapping: &mut BTreeMap<String, String>) {
	for child in &block.children {
		if let Some(name) = keyframes_name_from_selector(&child.selector_suffix) {
			mapping
				.entry(name.clone())
				.or_insert_with(|| format!("{name}-{hash}"));
		}
		collect_keyframe_names(child, hash, mapping);
	}
}

fn rewrite_block_with_keyframes(block: &CssBlock, mapping: &BTreeMap<String, String>) -> CssBlock {
	let selector_suffix = if let Some(name) = keyframes_name_from_selector(&block.selector_suffix) {
		if let Some(scoped_name) = mapping.get(&name) {
			format!("@keyframes {scoped_name}")
		} else {
			block.selector_suffix.clone()
		}
	} else {
		block.selector_suffix.clone()
	};

	let segments = block
		.segments
		.iter()
		.map(|segment| rewrite_animation_segment(segment, mapping))
		.collect();
	let children = block
		.children
		.iter()
		.map(|child| rewrite_block_with_keyframes(child, mapping))
		.collect();

	CssBlock {
		selector_suffix,
		segments,
		children,
	}
}

fn rewrite_animation_segment(segment: &str, mapping: &BTreeMap<String, String>) -> String {
	if let Some((property, value)) = segment.split_once(':') {
		let property = property.trim();
		if property == "animation" || property == "animation-name" {
			let rewritten = replace_identifiers_in_value(value.trim(), mapping);
			return format!("{property}: {rewritten}");
		}
	}
	segment.to_string()
}

fn replace_identifiers_in_value(value: &str, mapping: &BTreeMap<String, String>) -> String {
	let mut result = String::new();
	let mut ident = String::new();

	for ch in value.chars() {
		if ch.is_ascii_alphanumeric() || ch == '_' || ch == '-' {
			ident.push(ch);
			continue;
		}

		if !ident.is_empty() {
			if let Some(replacement) = mapping.get(&ident) {
				result.push_str(replacement);
			} else {
				result.push_str(&ident);
			}
			ident.clear();
		}
		result.push(ch);
	}

	if !ident.is_empty() {
		if let Some(replacement) = mapping.get(&ident) {
			result.push_str(replacement);
		} else {
			result.push_str(&ident);
		}
	}

	result
}

fn format_css_segments(segments: &[String], indent_level: usize) -> String {
	if segments.is_empty() {
		return String::new();
	}

	// Don't call canonical_segments again - segments are already normalized
	// Just format them with proper indentation
	let indent = "\t".repeat(indent_level);
	let mut result = String::new();
	for (i, segment) in segments.iter().enumerate() {
		// Remove space before colons in array values
		let cleaned = segment.replace(" :", ":").replace(" ;", ";");

		// Don't add newline after last segment
		if i < segments.len() - 1 {
			result.push_str(&format!("{}{};\n", indent, cleaned));
		} else {
			result.push_str(&format!("{}{};", indent, cleaned));
		}
	}

	result
}

/// Generates CSS with media queries for responsive breakpoints
fn format_media_queries_block(hash: &str, segments: &[String], break_points: &[u32]) -> String {
	let mut rules = Vec::new();
	let num_breakpoints = break_points.len();

	// Generate media queries for each breakpoint range
	for i in 0..num_breakpoints {
		let media_condition = format!("@media (max-width: var(--{}))", get_bp_name(i));

		let mut media_segments = Vec::new();
		for segment in segments {
			if let Some((property, value)) = segment.split_once(':') {
				let value_trimmed = value.trim();
				if is_array_value(value_trimmed) {
					if let Some(array_values) = parse_array_value(value_trimmed) {
						// Get the value for this breakpoint index
						let value_index = if i < array_values.len() {
							i
						} else {
							array_values.len() - 1
						};
						let selected_value = &array_values[value_index];
						media_segments.push(format!("{}: {}", property.trim(), selected_value));
					} else {
						media_segments.push(segment.clone());
					}
				} else {
					media_segments.push(segment.clone());
				}
			} else {
				media_segments.push(segment.clone());
			}
		}

		let body = format_css_segments(&media_segments, 2);
		rules.push(format!(
			"{} {{\n\t.{} {{\n{}\n\t}}\n}}",
			media_condition, hash, body
		));
	}

	// Add fallback rule for screens larger than the last breakpoint
	let mut fallback_segments = Vec::new();
	for segment in segments {
		if let Some((property, value)) = segment.split_once(':') {
			let value_trimmed = value.trim();
			if is_array_value(value_trimmed) {
				if let Some(array_values) = parse_array_value(value_trimmed) {
					let last_value = array_values.last().unwrap();
					fallback_segments.push(format!("{}: {}", property.trim(), last_value));
				} else {
					fallback_segments.push(segment.clone());
				}
			} else {
				fallback_segments.push(segment.clone());
			}
		} else {
			fallback_segments.push(segment.clone());
		}
	}

	let fallback_body = format_css_segments(&fallback_segments, 1);
	rules.push(format!(".{} {{\n{}\n}}", hash, fallback_body));

	rules.join("\n\n")
}

/// Gets CSS variable name for a breakpoint index
fn get_bp_name(index: usize) -> &'static str {
	match index {
		0 => "bp-sm",
		1 => "bp-md",
		2 => "bp-lg",
		3 => "bp-xl",
		_ => "bp-unknown",
	}
}

#[derive(Debug)]
struct MacroEntry {
	hash: String,
	block: CssBlock,
}

#[cfg(test)]
mod tests;
