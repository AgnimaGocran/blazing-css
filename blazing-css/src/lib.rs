use std::{
	collections::BTreeMap,
	env,
	error::Error,
	fs,
	path::{Path, PathBuf},
};

use blazing_css_core::{canonical_segments_from_stream, hash_css_segments};
pub use blazing_css_macro::css;
use itertools::Itertools;
use proc_macro2::{Delimiter, TokenStream, TokenTree};

#[derive(Debug, Clone, Copy)]
pub struct RenderOptions {
	pub emit_cargo_directives: bool,
}

impl Default for RenderOptions {
	fn default() -> Self {
		Self {
			emit_cargo_directives: true,
		}
	}
}

pub fn render_css(file_name: &str) -> Result<(), Box<dyn Error>> {
	render_css_with_options(file_name, RenderOptions::default())
}

pub fn render_css_with_options(
	file_name: &str, options: RenderOptions,
) -> Result<(), Box<dyn Error>> {
	let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
	if options.emit_cargo_directives {
		println!("cargo:rerun-if-changed=build.rs");
	}

	let src_dir = manifest_dir.join("src");
	let files = collect_rust_files(&src_dir)?;
	let mut gathered: BTreeMap<PathBuf, Vec<MacroEntry>> = BTreeMap::new();

	for file in files {
		if options.emit_cargo_directives {
			println!("cargo:rerun-if-changed={}", file.display());
		}
		let entries = process_file(&file)?;
		if !entries.is_empty() {
			gathered.insert(file, entries);
		}
	}

	let styles_path = manifest_dir.join(file_name);
	write_stylesheet(&styles_path, &manifest_dir, &gathered)?;

	Ok(())
}

fn collect_rust_files(dir: &Path) -> Result<Vec<PathBuf>, Box<dyn Error>> {
	let mut files = Vec::new();
	if dir.is_dir() {
		for entry in fs::read_dir(dir)? {
			let entry = entry?;
			let path = entry.path();
			if path.is_dir() {
				files.extend(collect_rust_files(&path)?);
			} else if path.extension().is_some_and(|ext| ext == "rs") {
				files.push(path);
			}
		}
	}
	files.sort();
	Ok(files)
}

fn process_file(path: &Path) -> Result<Vec<MacroEntry>, Box<dyn Error>> {
	let source = fs::read_to_string(path)?;
	let tokens = source.parse::<TokenStream>()?;
	let mut entries = Vec::new();
	scan_stream(tokens, &mut entries);
	Ok(entries)
}

fn scan_stream(stream: TokenStream, entries: &mut Vec<MacroEntry>) {
	let mut iter = stream.into_iter().peekable();
	while let Some(token) = iter.next() {
		match token {
			TokenTree::Ident(ident) if ident == "css" => {
				if matches!(iter.peek(), Some(TokenTree::Punct(p)) if p.as_char() == '!') {
					iter.next();
					if let Some(TokenTree::Group(group)) = iter.next() {
						if group.delimiter() == Delimiter::Brace {
							let inner = group.stream();
							let segments = canonical_segments_from_stream(&inner);
							let hash = hash_css_segments(&segments);
							entries.push(MacroEntry { hash, segments });
							scan_stream(inner, entries);
							continue;
						}
						scan_stream(group.stream(), entries);
						continue;
					}
				}
			}
			TokenTree::Group(group) => {
				scan_stream(group.stream(), entries);
			}
			_ => {}
		}
	}
}

fn write_stylesheet(
	output_path: &Path, manifest_dir: &Path, files: &BTreeMap<PathBuf, Vec<MacroEntry>>,
) -> Result<(), Box<dyn Error>> {
	let content = files
		.iter()
		.map(|(file, entries)| {
			format!(
				"/* {file} */\n{styles}",
				file = file
					.strip_prefix(manifest_dir)
					.unwrap_or(file)
					.display()
					.to_string(),
				styles = entries
					.iter()
					.map(|entry| format_css_block(&entry.hash, &entry.segments))
					.collect::<Vec<_>>()
					.join("\n\n")
			)
		})
		.join("\n\n");

	fs::write(
		output_path,
		format!("/* This is autogenerated file by blazing_css, do not edit it! */\n\n{content}"),
	)?;
	Ok(())
}

fn format_css_block(hash: &str, segments: &[String]) -> String {
	if segments.is_empty() {
		return format!(".{hash} {{\n}}", hash = hash);
	}

	format!(
		".{hash} {{\n{body}\n}}",
		hash = hash,
		body = format_css_segments(segments)
	)
}

fn format_css_segments(segments: &[String]) -> String {
	segments
		.iter()
		.map(|segment| format!("\t{};", segment))
		.collect::<Vec<_>>()
		.join("\n")
}

#[derive(Debug)]
struct MacroEntry {
	hash: String,
	segments: Vec<String>,
}
