use std::{
	collections::BTreeMap,
	env,
	error::Error,
	fs,
	path::{Path, PathBuf},
};

use blazing_css_core::{canonical_segments_from_stream, hash_css_segments, is_array_value, parse_array_value};
pub use blazing_css_macro::css;
use itertools::Itertools;
use proc_macro2::{Delimiter, TokenStream, TokenTree};

#[derive(Debug, Clone)]
pub struct RenderOptions {
	pub emit_cargo_directives: bool,
	pub break_points: Option<Vec<u32>>,
}

impl Default for RenderOptions {
	fn default() -> Self {
		Self {
			emit_cargo_directives: true,
			break_points: Some(vec![640, 1024, 1440]),
		}
	}
}

pub fn render_css(file_name: &str) -> Result<(), Box<dyn Error>> {
	render_css_with_options(file_name, RenderOptions::default())
}

pub fn render_css_with_options(
	file_name: &str, options: RenderOptions,
) -> Result<(), Box<dyn Error>> {
	let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
	if options.emit_cargo_directives {
		println!("cargo:rerun-if-changed=build.rs");
	}

	let src_dir = manifest_dir.join("src");
	let files = collect_rust_files(&src_dir)?;
	let mut gathered: BTreeMap<PathBuf, Vec<MacroEntry>> = BTreeMap::new();

	for file in files {
		if options.emit_cargo_directives {
			println!("cargo:rerun-if-changed={}", file.display());
		}
		let entries = process_file(&file)?;
		if !entries.is_empty() {
			gathered.insert(file, entries);
		}
	}

	let styles_path = manifest_dir.join(file_name);
	write_stylesheet(&styles_path, &manifest_dir, &gathered, options.break_points.as_ref())?;

	Ok(())
}

fn collect_rust_files(dir: &Path) -> Result<Vec<PathBuf>, Box<dyn Error>> {
	let mut files = Vec::new();
	if dir.is_dir() {
		for entry in fs::read_dir(dir)? {
			let entry = entry?;
			let path = entry.path();
			if path.is_dir() {
				files.extend(collect_rust_files(&path)?);
			} else if path.extension().is_some_and(|ext| ext == "rs") {
				files.push(path);
			}
		}
	}
	files.sort();
	Ok(files)
}

fn process_file(path: &Path) -> Result<Vec<MacroEntry>, Box<dyn Error>> {
	let source = fs::read_to_string(path)?;
	let tokens = source.parse::<TokenStream>()?;
	let mut entries = Vec::new();
	scan_stream(tokens, &mut entries);
	Ok(entries)
}

fn scan_stream(stream: TokenStream, entries: &mut Vec<MacroEntry>) {
	let mut iter = stream.into_iter().peekable();
	while let Some(token) = iter.next() {
		match token {
			TokenTree::Ident(ident) if ident == "css" => {
				if matches!(iter.peek(), Some(TokenTree::Punct(p)) if p.as_char() == '!') {
					iter.next();
					if let Some(TokenTree::Group(group)) = iter.next() {
						if group.delimiter() == Delimiter::Brace {
							let inner = group.stream();
							let segments = canonical_segments_from_stream(&inner);
							let hash = hash_css_segments(&segments);
							entries.push(MacroEntry { hash, segments });
							scan_stream(inner, entries);
							continue;
						}
						scan_stream(group.stream(), entries);
						continue;
					}
				}
			}
			TokenTree::Group(group) => {
				scan_stream(group.stream(), entries);
			}
			_ => {}
		}
	}
}

fn write_stylesheet(
	output_path: &Path, manifest_dir: &Path, files: &BTreeMap<PathBuf, Vec<MacroEntry>>,
	break_points: Option<&Vec<u32>>,
) -> Result<(), Box<dyn Error>> {
	let css_vars = if let Some(bps) = break_points {
		format_breakpoint_css_vars(bps)
	} else {
		String::new()
	};

	let content = files
		.iter()
		.map(|(file, entries)| {
			format!(
				"/* {file} */\n{styles}",
				file = file
					.strip_prefix(manifest_dir)
					.unwrap_or(file)
					.display()
					.to_string(),
				styles = entries
					.iter()
					.map(|entry| format_css_block(&entry.hash, &entry.segments, break_points))
					.collect::<Vec<_>>()
					.join("\n\n")
			)
		})
		.join("\n\n");

	let header = "/* This is autogenerated file by blazing-css, do not edit it! */\n\n";
	let body = if css_vars.is_empty() {
		format!("{header}{content}")
	} else {
		format!("{header}{css_vars}\n\n{content}")
	};

	fs::write(output_path, body)?;
	Ok(())
}

/// Formats CSS variables for breakpoints
fn format_breakpoint_css_vars(break_points: &[u32]) -> String {
	let mut vars = Vec::new();
	for (i, bp) in break_points.iter().enumerate() {
		let name = match i {
			0 => "--bp-sm",
			1 => "--bp-md",
			2 => "--bp-lg",
			3 => "--bp-xl",
			_ => &format!("--bp-{}", i),
		};
		vars.push(format!("\t{}: {}px;", name, bp));
	}

	format!(":root {{\n{}\n}}", vars.join("\n"))
}

fn format_css_block(hash: &str, segments: &[String], break_points: Option<&Vec<u32>>) -> String {
	if segments.is_empty() {
		return format!(".{hash} {{\n}}", hash = hash);
	}

	// Check if any segment has array values with multiple elements
	// Single value in brackets [row] or no brackets row -> no media query
	// Multiple values in brackets [row, column] -> media query
	let has_multi_value_array = segments.iter().any(|seg| {
		if let Some((_, value)) = seg.split_once(':') {
			let value_trimmed = value.trim();
			if is_array_value(value_trimmed) {
				if let Some(array_values) = parse_array_value(value_trimmed) {
					array_values.len() > 1
				} else {
					false
				}
			} else {
				false
			}
		} else {
			false
		}
	});

	if has_multi_value_array {
		if let Some(bps) = break_points {
			return format_media_queries_block(hash, segments, bps);
		} else {
			// Should not happen with default break_points
			return format_media_queries_block(hash, segments, &[640, 1024, 1440]);
		}
	}

	// If no multi-value arrays, extract first value from single-value arrays and remove brackets
	let processed_segments: Vec<String> = segments.iter().map(|seg| {
		if let Some((property, value)) = seg.split_once(':') {
			let value_trimmed = value.trim();
			if is_array_value(value_trimmed) {
				if let Some(array_values) = parse_array_value(value_trimmed) {
					if let Some(first_value) = array_values.first() {
						format!("{}: {}", property.trim(), first_value)
					} else {
						seg.clone()
					}
				} else {
					seg.clone()
				}
			} else {
				seg.clone()
			}
		} else {
			seg.clone()
		}
	}).collect();

	format!(
		".{hash} {{\n{body}\n}}",
		hash = hash,
		body = format_css_segments(&processed_segments, 1)
	)
}

fn format_css_segments(segments: &[String], indent_level: usize) -> String {
	if segments.is_empty() {
		return String::new();
	}

	// Don't call canonical_segments again - segments are already normalized
	// Just format them with proper indentation
	let indent = "\t".repeat(indent_level);
	let mut result = String::new();
	for (i, segment) in segments.iter().enumerate() {
		// Remove space before colons in array values
		let cleaned = segment.replace(" :", ":").replace(" ;", ";");

		// Don't add newline after last segment
		if i < segments.len() - 1 {
			result.push_str(&format!("{}{};\n", indent, cleaned));
		} else {
			result.push_str(&format!("{}{};", indent, cleaned));
		}
	}

	result
}

/// Generates CSS with media queries for responsive breakpoints
fn format_media_queries_block(hash: &str, segments: &[String], break_points: &[u32]) -> String {
	let mut rules = Vec::new();
	let num_breakpoints = break_points.len();

	// Generate media queries for each breakpoint range
	for i in 0..num_breakpoints {
		let media_condition = format!("@media (max-width: var(--{}))", get_bp_name(i));

		let mut media_segments = Vec::new();
		for segment in segments {
			if let Some((property, value)) = segment.split_once(':') {
				let value_trimmed = value.trim();
				if is_array_value(value_trimmed) {
					if let Some(array_values) = parse_array_value(value_trimmed) {
						// Get the value for this breakpoint index
						let value_index = if i < array_values.len() {
							i
						} else {
							array_values.len() - 1
						};
						let selected_value = &array_values[value_index];
						media_segments.push(format!("{}: {}", property.trim(), selected_value));
					} else {
						media_segments.push(segment.clone());
					}
				} else {
					media_segments.push(segment.clone());
				}
			} else {
				media_segments.push(segment.clone());
			}
		}

		let body = format_css_segments(&media_segments, 2);
		rules.push(format!("{} {{\n\t.{} {{\n{}\n\t}}\n}}", media_condition, hash, body));
	}

	// Add fallback rule for screens larger than the last breakpoint
	let mut fallback_segments = Vec::new();
	for segment in segments {
		if let Some((property, value)) = segment.split_once(':') {
			let value_trimmed = value.trim();
			if is_array_value(value_trimmed) {
				if let Some(array_values) = parse_array_value(value_trimmed) {
					let last_value = array_values.last().unwrap();
					fallback_segments.push(format!("{}: {}", property.trim(), last_value));
				} else {
					fallback_segments.push(segment.clone());
				}
			} else {
				fallback_segments.push(segment.clone());
			}
		} else {
			fallback_segments.push(segment.clone());
		}
	}

	let fallback_body = format_css_segments(&fallback_segments, 1);
	rules.push(format!(".{} {{\n{}\n}}", hash, fallback_body));

	rules.join("\n\n")
}

/// Gets CSS variable name for a breakpoint index
fn get_bp_name(index: usize) -> &'static str {
	match index {
		0 => "bp-sm",
		1 => "bp-md",
		2 => "bp-lg",
		3 => "bp-xl",
		_ => "bp-unknown",
	}
}

#[derive(Debug)]
struct MacroEntry {
	hash: String,
	segments: Vec<String>,
}
